## 2216. Minimum Deletions to Make Array Beautiful

https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/

You are given a **0-indexed** integer array `nums`. The array `nums` is **beautiful** if:

- `nums.length` is even.
- `nums[i] != nums[i + 1]` for all `i % 2 == 0`.

Note that an empty array is considered beautiful.

You can delete any number of elements from `nums`. When you delete an element, all the elements to the right of the deleted element will be **shifted one unit to the left** to fill the gap created and all the elements to the left of the deleted element will remain **unchanged**.

Return *the **minimum** number of elements to delete from* `nums` *to make it* *beautiful.*

 

**Example 1:**

```
Input: nums = [1,1,2,3,5]
Output: 1
Explanation: You can delete either nums[0] or nums[1] to make nums = [1,2,3,5] which is beautiful. It can be proven you need at least 1 deletion to make nums beautiful.
```

**Example 2:**

```
Input: nums = [1,1,2,2,3,3]
Output: 2
Explanation: You can delete nums[0] and nums[5] to make nums = [1,2,2,3] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`



### 代码

- 见注释

```java
class Solution {
    public int minDeletion(int[] nums) {
        // 贪心算法？
        // 这里i和j分别表示左右比较的元素下标，j一直向右找到与i不同的地方，然后i从j+1继续.
        int del = 0, n = nums.length;
        for (int i = 0; i < n - 1;) {
            int j = i + 1;
            while (j < n && nums[j] == nums[i]) {
                j++;
                del++;
            }
            i = j + 1;
        }
        // 判断数组长度是否为奇数，若为奇数则删掉最后一个元素即可
        if ((n - del) % 2 == 1) {
            del++;
        }
        return del;
    }
}
```

