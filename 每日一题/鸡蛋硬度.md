## AcWing 1048. 鸡蛋硬度

https://www.acwing.com/problem/content/description/1050/

**题目描述**
最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。

参赛者是来自世界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法–从高度扔鸡蛋–来测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。

你当然可以找出各种理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从100 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样–这比赛不过是XX公司的一个另类广告而已。

勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。

“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定啊……3个鸡蛋怎么办，4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。

好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了。

**输入格式**
输入包括多组数据，每组数据一行，包含两个正整数 n 和 m，其中 n 表示楼的高度，m 表示你现在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于 n。

你可以假定硬度为 x 的鸡蛋从高度小于等于 x 的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比 x 高的地方扔必然会碎。

对每组输入数据，你可以假定鸡蛋的硬度在 0 至 n 之间，即在 n+1 层扔鸡蛋一定会碎。

**输出格式**
对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。

**数据范围**
1≤n≤100
1≤m≤10
**输入样例**
100 1
100 2

**输出样例**

100
14

**样例解释**
最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。

如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要扔无限次，所以第一组数据的答案是100。



### 代码

- f[i, j]表示i层楼，j个鸡蛋的测量方案中最坏情况的最小值
  j个鸡蛋在足够多的情况下可以不用全部用完
  状态转移：
  不使用第j个鸡蛋，方案数为f[i, j - 1]
  使用第j个鸡蛋，则有1~i层楼共i种情况可以扔，假设在第k层扔：
  蛋碎，搜索区间变成1~k-1，鸡蛋个数减一，方案数为f[k - 1, j - 1]
  蛋没碎，搜索区间变成k+1~i，第j个蛋可重复利用，方案数为f[i - k, j]
  枚举扔的楼层k，在所有可行方案中选择最大值即为最坏情况，答案就是这些情况的最小值

```cpp
#include<iostream>
using namespace std;

int f[110][15], n, m;

int main() {
    while (cin >> n >> m) {
        for (int i = 1; i <= n; i++) f[i][1] = i;
        for (int j = 1; j <= m; j++) f[1][j] = 1;
        for (int i = 2; i <= n; i++)
            for (int j = 2; j <= m; j++) {
                f[i][j] = f[i][j - 1];
                for (int k = 1; k <= i; k++) {
                    f[i][j] = min(f[i][j], max(f[k - 1][j - 1], f[i - k][j]) + 1);
                }
            }
        printf("%d\n", f[n][m]);
    }
    return 0;
}
```

