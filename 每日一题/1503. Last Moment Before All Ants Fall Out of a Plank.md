## leetcode 1503. Last Moment Before All Ants Fall Out of a Plank

#### 题目

We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with speed **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**.

When two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions doesn't take any additional time.

When an ant reaches **one end** of the plank at a time `t`, it falls out of the plank imediately.

Given an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right. Return *the moment* when the last ant(s) fall out of the plank.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/06/17/ants.jpg)

```
Input: n = 4, left = [4,3], right = [0,1]
Output: 4
Explanation: In the image above:
-The ant at index 0 is named A and going to the right.
-The ant at index 1 is named B and going to the right.
-The ant at index 3 is named C and going to the left.
-The ant at index 4 is named D and going to the left.
Note that the last moment when an ant was on the plank is t = 4 second, after that it falls imediately out of the plank. (i.e. We can say that at t = 4.0000000001, there is no ants on the plank).
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg)

```
Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]
Output: 7
Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg)

```
Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []
Output: 7
Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.
```

**Example 4:**

```
Input: n = 9, left = [5], right = [4]
Output: 5
Explanation: At t = 1 second, both ants will be at the same intial position but with different direction.
```

**Example 5:**

```
Input: n = 6, left = [6], right = [0]
Output: 6
```

#### 思路

- 可以把问题想象成：蚂蚁相遇时，虽然互换了方向，但也可以看成互相“穿过”，即相遇之后左边的蚂蚁照样来到右边，右边的蚂蚁一样可以穿到左边，因为我们只考虑所有蚂蚁都掉落的情况，并不关心具体是哪一边的蚂蚁。

- 既然相遇问题可看作是“穿过”，那么我们只用比较：

  1. 如果left数组存在，则需要找最右边(max(left))那个蚂蚁到最左边的(0)的距离dist1。

  2. 如果right数组存在，则需要找最左边(max(right))那个蚂蚁到最右边的(n)的距离dist2。
  3. 最后取max(dist1, dist2)

#### 代码

```java
class Solution {
    public int getLastMoment(int n, int[] left, int[] right) {
        int steps = 0;
        for (int i : left) {
            steps = Math.max(steps, i);
        }
        for (int j : right) {
            steps = Math.max(steps, n - j);
        }
        return steps;
    }
}
```

